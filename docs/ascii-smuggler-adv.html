<!DOCTYPE html>
<html>
<head>
  <title>ASCII Smuggler ‚Äì Hide and Reveal ASCII with Invisible Unicode Encodings</title>
  <meta name="viewport" content="width=device-width, initial-scale=0.9">
  <link rel="shortcut icon" type="image/x-icon" href="https://embracethered.com/blog/images/favicon.ico" />
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@wunderwuzzi23">
  <meta name="twitter:title" content="ASCII Smuggler ‚Äì Hide and Reveal ASCII with Invisible Unicode Encodings">
  <meta name="twitter:description" content="Convert ASCII text into invisible Unicode encodings using Unicode Tags, Variant Selectors, and Sneaky Bits, and decode hidden messages.">
  <meta name="twitter:image" content="https://embracethered.com/blog/images/2024/ascii-smuggler-logo.png">
  <meta name="twitter:creator" content="@wunderwuzzi23">
  <style>
    body {
      font-family: sans-serif;
      padding: 0px 10px;
      font-size: 16px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      text-align: center;
    }
    textarea, #outputMessage {
      width: 100%;
      margin: 10px 0;
      height: 120px;
      border: 1px solid #ccc;
      padding: 10px;
      box-sizing: border-box;
      font-family: monospace;
      font-size: 14px;
      text-align: left;
      resize: vertical;
      background-color: rgba(255, 255, 255, 0.95);
      color: #000;
      box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.2);
    }
    #outputMessage {
      background-color: #f0f0f0;
      overflow-y: auto;
      white-space: pre-wrap;
      display: block;
      min-height: 100px;
      border: 1px solid #ccc;
      padding: 10px;
    }
    #statusMessage {
      margin-bottom: 10px;
      white-space: pre-wrap;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      margin: 10px 5px 10px 0;
      cursor: pointer;
    }
    .highlight {
      background-color: yellow;
      font-family: monospace;
    }
    .variant {
      background-color: lightblue;
      font-family: monospace;
    }
    .invisible {
      background-color: lightgreen;
      font-family: monospace;
    }
    .binary {
      background-color: lightgray;
      font-family: monospace;
    }
    .advanced-options {
      display: none;
      background-color: cyan;
      text-align: center;
      margin-top: 5px;
      font-size: 14px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .advanced-options.visible {
      display: block;
    }
    .verbose-info {
      display: none;
    }
    .verbose-info.visible {
      display: block;
    }
    .advanced-options label {
      margin-right: 20px;
      display: inline-block;
    }
    .toggle-advanced {
      font-size: 14px;
      color: #007bff;
      text-decoration: underline;
      cursor: pointer;
      display: inline-block;
      margin: 0px 0;
    }
    .char-button {
      display: inline-block;
      margin: 3px;
      padding: 5px 10px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .char-button:hover {
      background-color: #e0e0e0;
    }
    .emoji-button {
      display: inline-block;
      margin: 3px;
      padding: 5px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
    }
    .emoji-button:hover {
      background-color: #e0e0e0;
    }
    fieldset {
      border: none;
      padding: 0;
      margin: 10px 0;
    }
    legend {
      font-weight: bold;
      margin-bottom: 5px;
    }
    .stat-item {
      flex: 1 0 30%;
      margin: 5px;
      padding: 5px;
      background-color: #e9e9e9;
      border-radius: 4px;
      text-align: center;
      border: 1px solid #ccc;
    }
    .stat-item span {
      font-weight: bold;
      color: #007bff;
    }
  </style>
</head>
<body>

<div class="container">
  <h1>ASCII Smuggler</h1>
  <span>
    Convert ASCII text to invisible Unicode encodings and decode hidden secrets.
    <br>
    Use the options below to choose an encoding strategy and select which hidden sets to detect.
  </span>
  <br>
  <textarea id="inputMessage" placeholder="Enter your message here"></textarea>
  <button id="encodeButton">Encode & Copy</button>
  <button id="decodeButton">Decode</button>
  <br> 

  <a href="javascript:void(0);" class="toggle-advanced">Toggle Advanced Options</a>
  <div class="advanced-options" id="advancedOptions">
    <fieldset>
      <legend>Encoding Options</legend>
      <label>
        <input type="radio" name="encodingStrategy" value="unicode" checked>
        Unicode Tags
      </label>
      <label>
        <input type="radio" name="encodingStrategy" value="variant">
        Variant Selectors
      </label>
      <label>
        <input type="radio" name="encodingStrategy" value="binary">
        Sneaky Bits (UTF‚Äë8)
      </label>
      <div id="variantOptions" style="display:none; margin-top: 5px;">
        <label>
          VS2 Offset:
          <input type="number" id="vs2Offset" value="16" style="width: 50px;">
        </label>
      </div>
      <div id="unicodeTagOptions" style="display:none; margin-top: 5px;">
        <label title="Add explicit BEGIN and END tags">
          <input type="checkbox" id="addExplicitTags" checked>
          Add BEGIN/END Tags
        </label>
      </div>
      <div id="binaryOptions" style="display:none; margin-top: 5px;">
        <label>
          Binary 0:
          <input type="text" id="binary0" maxlength="1" value="&#x2062;" style="width: 30px;">
        </label>
        <label>
          Binary 1:
          <input type="text" id="binary1" maxlength="1" value="&#x2064;" style="width: 30px;">
        </label>
      </div>
    </fieldset>
    <fieldset>
      <legend>Input Options</legend>
      <div>
        <span class="char-button" title="Zero Width Space (U+200B)" data-char="&#x200B;">ZWSP</span>
        <span class="char-button" title="Zero Width Non-Joiner (U+200C)" data-char="&#x200C;">ZWNJ</span>
        <span class="char-button" title="Zero Width Joiner (U+200D)" data-char="&#x200D;">ZWJ</span>
        <span class="char-button" title="Word Joiner (U+2060)" data-char="&#x2060;">WJ</span>
        <span class="char-button" title="Invisible Times (U+2062)" data-char="&#x2062;">√ó</span>
        <span class="char-button" title="Invisible Plus (U+2064)" data-char="&#x2064;">+</span>
      </div>
      <div>
        <span class="emoji-button" title="Smiling Face" data-char="üòä">üòä</span>
        <span class="emoji-button" title="Evil Face" data-char="üòà">üòà</span>
        <span class="emoji-button" title="Developer" data-char="üë®‚Äçüíª">üë®‚Äçüíª</span>
        <span class="emoji-button" title="Ninja" data-char="ü•∑">ü•∑</span>
        <span class="emoji-button" title="Ghost" data-char="üëª">üëª</span>
      </div>
    </fieldset>
    <fieldset>
      <legend>Decoding Options</legend>
      <label title="Decodes URI components before processing">
        <input type="checkbox" id="decodeUriComponent">
        Decode URL components
      </label>
      <label title="Highlights only the decoded hidden characters">
        <input type="checkbox" id="highlightMode" checked>
        Highlight Mode
      </label>
      <label title="Automatically decodes input as you type">
        <input type="checkbox" id="autoDecodeInput">
        Auto-decode Input
      </label>
      <label title="Shows detailed debug information">
        <input type="checkbox" id="showVerboseInfo">
        Show Verbose Info
      </label>
      <br>
      <label>
        <input type="checkbox" id="detectUnicodeTags" checked>
        Detect Unicode Tags
      </label>
      <label>
        <input type="checkbox" id="detectVariantSelectors" checked>
        Detect Variant Selectors
      </label>
      <label title="Highlights invisible Unicode characters with friendly names and hex codes: Zero Width Space (U+200B), Zero Width Non-Joiner (U+200C), Zero Width Joiner (U+200D), Left-to-Right Mark (U+200E), Right-to-Left Mark (U+200F), Left-to-Right Embedding (U+202A), Right-to-Left Embedding (U+202B), Pop Directional Formatting (U+202C), Left-to-Right Override (U+202D), Right-to-Left Override (U+202E), Soft Hyphen (U+00AD), Byte Order Mark (U+FEFF), Word Joiner (U+2060), Function Application (U+2061), Invisible Times (U+2062), Invisible Separator (U+2063), Invisible Plus (U+2064)">
        <input type="checkbox" id="detectOtherInvisible" checked>
        Detect Other Invisible
      </label>
      <label title="Detects and decodes binary sequences encoded with invisible characters">
        <input type="checkbox" id="detectSneakyBits" checked>
        Detect Sneaky Bits
      </label>
    </fieldset>
  </div>
  
  <div id="outputMessage" class="outputMessage"></div>
  <div id="statusMessage" style="font-weight: bold;"></div>
  <div class="verbose-info" id="verboseInfoSection">
    <div style="border: 2px solid #007bff; border-radius: 5px; padding: 10px; background-color: #f0f8ff;">
      <div style="margin-bottom: 10px; font-weight: bold; color: #007bff; border-bottom: 1px solid #007bff; padding-bottom: 5px;">
        Debug Output Format
      </div>
      <div>
        <label>
          <input type="radio" name="debugFormat" value="binary" checked> Binary
        </label>
        <label>
          <input type="radio" name="debugFormat" value="hex"> Hexadecimal
        </label>
        <label>
          <input type="radio" name="debugFormat" value="unicode"> Unicode
        </label>
      </div>
      <div id="debugOutput" style="width: 100%; margin: 10px 0; height: 80px; border: 1px solid #ccc; padding: 10px; box-sizing: border-box; font-family: monospace; font-size: 14px; text-align: left; resize: vertical; background-color: #f8f8f8; color: #000; overflow-y: auto; white-space: pre-wrap; display: block; min-height: 80px;" readonly></div>
    </div>
  </div>
 
  <div id="statsOutput" style="width: 100%; margin: 10px 0; padding: 10px; box-sizing: border-box; font-family: sans-serif; font-size: 14px; text-align: left; background-color: #f0f0f0; border: 1px solid #ccc;">
    <!-- Summary row with larger numbers -->
    <div style="display: flex; justify-content: space-around; margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 15px;">
      <div class="stat-item" style="flex: 1; max-width: 45%;">
        <div style="font-size: 14px;">Total Characters</div>
        <div style="font-size: 24px; font-weight: bold; color: #333;"><span id="totalChars">0</span></div>
      </div>
      <div class="stat-item" style="flex: 1; max-width: 45%;">
        <div style="font-size: 14px;">Total Hidden Characters</div>
        <div style="font-size: 24px; font-weight: bold; color: #007bff;"><span id="totalHiddenChars">0</span></div>
      </div>
    </div>
    <!-- Condensed details row -->
    <div style="display: flex; flex-wrap: wrap; justify-content: space-between; font-size: 13px;">
      <div class="stat-item" style="flex: 1 0 22%; padding: 5px; margin: 3px; text-align: center; display: flex; flex-direction: column; justify-content: center; min-height: 40px;">Unicode Tags: <span id="unicodeTagCount">0</span></div>
      <div class="stat-item" style="flex: 1 0 22%; padding: 5px; margin: 3px; text-align: center; display: flex; flex-direction: column; justify-content: center; min-height: 40px;">Variant Selectors: <span id="variantCount">0</span></div>
      <div class="stat-item" style="flex: 1 0 22%; padding: 5px; margin: 3px; text-align: center; display: flex; flex-direction: column; justify-content: center; min-height: 40px;">Other Invisible: <span id="invisibleCount">0</span></div>
      <div class="stat-item" style="flex: 0 0 22%; padding: 5px; margin: 3px; text-align: center; display: flex; flex-direction: column; justify-content: center; min-height: 40px;">
        <div>Sneaky Bit Characters: <span id="binaryBits">0</span></div>
        <div style="font-size: 12px; color: #666;">(SneakyBits √∑ 8: <span id="binaryBytes">0</span>)</div>
      </div>
    </div>
  </div>
  <button id="clearButton">Clear</button>
  <br><br>
  <a style="font-size: 14px" href="https://embracethered.com/blog/posts/2024/hiding-and-finding-text-with-unicode-tags/">
    Embrace the Red ‚Äì Blog Post
  </a>
</div>
 
<script>
  // Helper: escape special regex characters.
  function escapeForRegex(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  // Helper: Get the actual character from an input that might contain an HTML entity.
  function getBinaryChar(id) {
    let inputVal = document.getElementById(id)?.value;
    if (!inputVal) {
      // Return default values if the element doesn't exist yet
      return id === 'binary0' ? String.fromCodePoint(0x2062) : String.fromCodePoint(0x2064);
    }
    let temp = document.createElement("div");
    temp.innerHTML = inputVal;
    return temp.textContent;
  }

  // Define binary characters - these will be updated when the page loads
  let binary0 = getBinaryChar('binary0');
  let binary1 = getBinaryChar('binary1');

  // Update binary characters when the page loads
  document.addEventListener('DOMContentLoaded', function() {
    binary0 = getBinaryChar('binary0');
    binary1 = getBinaryChar('binary1');
  });

  // Update binary characters when the inputs change
  document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('binary0')?.addEventListener('change', function() {
      binary0 = getBinaryChar('binary0');
    });
    document.getElementById('binary1')?.addEventListener('change', function() {
      binary1 = getBinaryChar('binary1');
    });
  });

  const invisibleMapping = {
    0x200B: "Zero Width Space",
    0x200C: "Zero Width Non-Joiner",
    0x200D: "Zero Width Joiner",
    0x200E: "Left-to-Right Mark",
    0x200F: "Right-to-Left Mark",
    0x202A: "Left-to-Right Embedding",
    0x202B: "Right-to-Left Embedding",
    0x202C: "Pop Directional Formatting",
    0x202D: "Left-to-Right Override",
    0x202E: "Right-to-Left Override",
    0x00AD: "Soft Hyphen",
    0xFEFF: "Byte Order Mark / Zero Width No-Break Space",
    0x2060: "Word Joiner",
    0x2061: "Function Application",
    0x2062: "Invisible Times",
    0x2063: "Invisible Separator",
    0x2064: "Invisible Plus"
  };

  function escapeHtml(text) {
    return text.replace(/&/g, "&amp;")
               .replace(/</g, "&lt;")
               .replace(/>/g, "&gt;");
  }

  // ----------------- Encoding Function -----------------
  function encodeMessage(message) {
    let encoded = '';
    let codePoints = '';
    let invalidChars = '';
    let strategy = document.querySelector('input[name="encodingStrategy"]:checked').value;
    if (strategy === 'unicode') {
      const addExplicitTags = document.getElementById('addExplicitTags').checked;
      
      if (addExplicitTags) {
        encoded += String.fromCodePoint(0xE0001);
        codePoints += 'U+E0001 ';
      }
      
      for (let char of message) {
        let charCode = char.charCodeAt(0);
        if (charCode >= 0x20 && charCode <= 0x7E) {
          let cp = 0xE0000 + charCode;
          encoded += String.fromCodePoint(cp);
          codePoints += 'U+' + cp.toString(16).toUpperCase() + ' ';
        } else {
          invalidChars += char;
        }
      }
      
      if (addExplicitTags) {
        encoded += String.fromCodePoint(0xE007F);
        codePoints += 'U+E007F';
      }
    } else if (strategy === 'variant') {
      let vs2Offset = parseInt(document.getElementById('vs2Offset').value, 10) || 16;
      for (let char of message) {
        let charCode = char.charCodeAt(0);
        if (charCode >= 0 && charCode <= 15) {
          let variantCode = 0xFE00 + charCode;
          encoded += String.fromCodePoint(variantCode);
          codePoints += 'U+' + variantCode.toString(16).toUpperCase() + ' ';
        } else if (charCode >= 16 && charCode <= 255) {
          let variantCode = 0xE0100 + (charCode - vs2Offset);
          encoded += String.fromCodePoint(variantCode);
          codePoints += 'U+' + variantCode.toString(16).toUpperCase() + ' ';
        } else {
          invalidChars += char;
        }
      }
    } else if (strategy === 'binary') {
      const encoderObj = new TextEncoder();
      const byteArray = encoderObj.encode(message);
      for (let byte of byteArray) {
        let bin = byte.toString(2).padStart(8, '0');
        for (let bit of bin) {
          encoded += (bit === '0' ? binary0 : binary1);
        }
        codePoints += bin + ' ';
      }
    }
    if (invalidChars.length > 0) {
      updateStatus('Invalid characters detected: ' + invalidChars);
    }
    return [codePoints, encoded];
  }

  // -------------- Recursive Token-Based Decoding Functions --------------
  // Each token: { text: string, highlight: boolean, title?: string, binary?: boolean }
  function recursiveDecodeTokens(text, options) {
    let tokens = [];
    let stats = { unicodeTagCount: 0, variantCount: 0, otherInvisibleCount: 0, binaryCount: 0 };
    let i = 0;
    while (i < text.length) {
      let cp = text.codePointAt(i);
      let char = String.fromCodePoint(cp);
      let inc = (cp > 0xFFFF) ? 2 : 1;
      // -- Unicode Tags --
      if (options.detectUnicodeTags && cp === 0xE0001) {
        i += inc;
        let tagContent = "";
        while (i < text.length) {
          let innerCp = text.codePointAt(i);
          let innerInc = (innerCp > 0xFFFF) ? 2 : 1;
          if (innerCp === 0xE007F) {
            i += innerInc;
            break;
          }
          if (innerCp >= 0xE0000 && innerCp < 0xE007F) {
            tagContent += String.fromCharCode(innerCp - 0xE0000);
          } else {
            tagContent += String.fromCodePoint(innerCp);
          }
          i += innerInc;
        }
        stats.unicodeTagCount += tagContent.length;
        let innerResult = recursiveDecodeTokens(tagContent, options);
        let decodedText = tokensToPlain(innerResult.tokens);
        tokens.push({
          text: decodedText,
          highlight: true,
          type: "tag",
          title: "Unicode Tag Decoded: " + tagContent
        });
        continue;
      }
      // -- Variant Selectors --
      if (options.detectVariantSelectors) {
        if (cp >= 0xFE00 && cp <= 0xFE00 + 15) {
          let decodedChar = String.fromCharCode(cp - 0xFE00);
          stats.variantCount++;
          tokens.push({
            text: decodedChar,
            highlight: true,
            type: "variant",
            title: "Variant Selector Decoded: " + decodedChar
          });
          i += inc;
          continue;
        }
        if (cp >= 0xE0100 + (16 - options.vs2Offset) && cp <= 0xE0100 + (255 - options.vs2Offset)) {
          let decodedChar = String.fromCharCode((cp - 0xE0100) + options.vs2Offset);
          stats.variantCount++;
          tokens.push({
            text: decodedChar,
            highlight: true,
            type: "variant",
            title: "Variant Selector Decoded: " + decodedChar
          });
          i += inc;
          continue;
        }
      }
      // -- Other Invisible Characters --
      if (options.detectOtherInvisible && invisibleMapping[cp]) {
        stats.otherInvisibleCount++;
        tokens.push({
          text: "U+" + cp.toString(16).toUpperCase(),
          highlight: true,
          type: "invisible",
          title: invisibleMapping[cp]
        });
        i += inc;
        continue;
      }
      // -- Binary (Sneaky Bits) --
      if (char === options.binary0 || char === options.binary1) {
        let run = "";
        while (i < text.length && (text[i] === options.binary0 || text[i] === options.binary1)) {
          run += text[i];
          i++;
        }
        if (options.decodeBinary) {
          if (run.length % 8 === 0) {
            let byteArray = [];
            for (let j = 0; j < run.length; j += 8) {
              let chunk = run.substr(j, 8);
              let binStr = "";
              for (let k = 0; k < chunk.length; k++) {
                binStr += (chunk[k] === options.binary0 ? '0' : '1');
              }
              byteArray.push(parseInt(binStr, 2));
            }
            try {
              let decoder = new TextDecoder("utf-8");
              let decodedSegment = decoder.decode(new Uint8Array(byteArray));
              // Count the decoded characters from this binary run.
              stats.binaryCount += decodedSegment.length;
              let innerResult = recursiveDecodeTokens(decodedSegment, options);
              let finalText = tokensToPlain(innerResult.tokens);
              tokens.push({
                text: finalText,
                highlight: true,
                type: "binary",
                title: "Sneaky Bits Decoded (" + decodedSegment.length + " characters)"
              });
            } catch(e) {
              tokens.push({
                text: run,
                highlight: true,
                type: "binary",
                title: "Binary Decode Error: " + e.message
              });
            }
          } else {
            tokens.push({ text: run, highlight: false });
          }
        } else {
          tokens.push({ 
            text: run, 
            highlight: true, 
            type: "binary", 
            title: "Sneaky Bits (pending decode)", 
            binary: true 
          });
        }
        continue;
      }
      // -- Default --
      tokens.push({ text: char, highlight: false });
      i += inc;
    }
    return { tokens: tokens, stats: stats };
  }

  function tokensToPlain(tokens) {
    return tokens.map(t => t.text).join("");
  }

  function tokensToHTML(tokens) {
    return tokens.map(t => {
      if (t.highlight) {
        let className = "highlight"; // Default yellow highlight
        if (t.type === "variant") {
          className = "variant";     // Light blue for variants
        } else if (t.type === "invisible") {
          className = "invisible";   // Light green for invisible
        } else if (t.type === "binary") {
          className = "binary";        // Light coral for binary
        }
        
        let extra = t.binary ? ' data-binary="true"' : '';
        return '<span class="' + className + '"' + extra + ' title="' + escapeHtml(t.title) + '">' + escapeHtml(t.text) + '</span>';
      } else {
        return t.binary ? '<span data-binary="true">' + escapeHtml(t.text) + '</span>' : escapeHtml(t.text);
      }
    }).join("");
  }

  // ----------------- Fully Decode Function -----------------
  // Repeatedly decodes until no further hidden text remains.
  function fullyDecode(text, options) {
    let prev = text;
    let aggregatedStats = { unicodeTagCount: 0, variantCount: 0, otherInvisibleCount: 0, binaryCount: 0 };
    let finalTokens = [];
    while (true) {
      let result = recursiveDecodeTokens(prev, options);
      aggregatedStats.unicodeTagCount += result.stats.unicodeTagCount;
      aggregatedStats.variantCount    += result.stats.variantCount;
      aggregatedStats.otherInvisibleCount += result.stats.otherInvisibleCount;
      aggregatedStats.binaryCount     += result.stats.binaryCount;
      let newPlain = tokensToPlain(result.tokens);
      if(newPlain === prev) {
        finalTokens = result.tokens;
        break;
      }
      prev = newPlain;
    }
    return { tokens: finalTokens, stats: aggregatedStats };
  }

  // ----------------- Event Listeners and Process Message -----------------
  document.getElementById('encodeButton').addEventListener('click', function() {
    processMessage('encode');
    copyToClipboard();
  });
  document.getElementById('decodeButton').addEventListener('click', function() {
    resetStatus();
    processMessage('decode');
  });
  document.getElementById('inputMessage').addEventListener('input', function() {
    resetStatus();
    // Auto-decode on input change if the option is checked
    if (document.getElementById('autoDecodeInput').checked) {
      processMessage('decode');
    }
  });
  document.getElementById('clearButton').addEventListener('click', function() {
    clearFields();
  });
  document.querySelector('.toggle-advanced').addEventListener('click', function() {
    const adv = document.getElementById('advancedOptions');
    adv.classList.toggle('visible');
    saveOptions();
  });
  document.querySelectorAll('input[name="encodingStrategy"]').forEach(radio => {
    radio.addEventListener('change', function() {
      if (this.value === 'variant') {
        document.getElementById('variantOptions').style.display = 'block';
        document.getElementById('binaryOptions').style.display = 'none';
        document.getElementById('unicodeTagOptions').style.display = 'none';
      } else if (this.value === 'binary') {
        document.getElementById('binaryOptions').style.display = 'block';
        document.getElementById('variantOptions').style.display = 'none';
        document.getElementById('unicodeTagOptions').style.display = 'none';
      } else if (this.value === 'unicode') {
        document.getElementById('unicodeTagOptions').style.display = 'block';
        document.getElementById('variantOptions').style.display = 'none';
        document.getElementById('binaryOptions').style.display = 'none';
      } else {
        document.getElementById('variantOptions').style.display = 'none';
        document.getElementById('binaryOptions').style.display = 'none';
        document.getElementById('unicodeTagOptions').style.display = 'none';
      }
      saveOptions();
    });
  });

  let clipboardData = '';

  // Process Message: For decoding, we no longer pre-decode binary sequences separately.
  // Instead, we directly process the message and add highlighted spans to the output.
  function processMessage(action) {
    let msg = document.getElementById('inputMessage').value;
    if (document.getElementById('decodeUriComponent').checked) {
      try {
        msg = decodeURIComponent(msg);
      } catch (e) {
        updateStatus('Error decoding URI component: ' + e.message);
        return;
      }
    }
    if (action === 'encode') {
      let [codePoints, encoded] = encodeMessage(msg);
      let strategy = document.querySelector('input[name="encodingStrategy"]:checked').value;
      // Don't clear the output, just append the new encoded content
      let currentOutput = document.getElementById('outputMessage').textContent;
      if (currentOutput && currentOutput.trim() !== '') {
        currentOutput += '\n\n';
      }
      document.getElementById('outputMessage').textContent = currentOutput + (strategy === 'binary' ? encoded : codePoints);
      clipboardData = encoded;
    } else {
      decodeMessage(msg);
    }
  }

  function decodeMessage(message) {
    let outputMessageElement = document.getElementById('outputMessage');
    let debugOutputElement = document.getElementById('debugOutput');
    outputMessageElement.innerHTML = '';
    
    const useHighlightMode = document.getElementById('highlightMode').checked;
    const detectVariantSelectors = document.getElementById('detectVariantSelectors').checked;
    const detectOtherInvisible = document.getElementById('detectOtherInvisible').checked;
    const detectUnicodeTags = document.getElementById('detectUnicodeTags').checked;
    const detectSneakyBits = document.getElementById('detectSneakyBits').checked;
    const vs2Offset = parseInt(document.getElementById('vs2Offset').value, 10) || 16;
    
    // Statistics for detected elements
    let stats = { 
      unicodeTagCount: 0, 
      variantCount: 0, 
      otherInvisibleCount: 0, 
      binaryBits: 0,
      totalChars: message.length
    };
    let detected = false;
    let sneakyBitsDetected = false;
    
    // Debug information collection
    let debugInfo = [];
    
    // Process the message
    for (let i = 0; i < message.length; i++) {
      let cp = message.codePointAt(i);
      let char = String.fromCodePoint(cp);
      let inc = (cp > 0xFFFF) ? 2 : 1;
      
      // Determine character type for debug info
      let type = 'regular';
      
      if (detectUnicodeTags && cp >= 0xE0000 && cp <= 0xE007F) {
        type = 'tag';
      } else if (detectVariantSelectors && 
                ((cp >= 0xFE00 && cp <= 0xFE0F) || 
                 (cp >= 0xE0100 + (16 - vs2Offset) && cp <= 0xE0100 + (255 - vs2Offset)))) {
        type = 'variant';
      } else if (detectOtherInvisible && invisibleMapping[cp]) {
        type = 'invisible';
      } else if (detectSneakyBits && (char === binary0 || char === binary1)) {
        type = 'binary';
        // We'll count these in the sneaky bits detection block to avoid double counting
      }
      
      // Add to debug info with proper type - always add the original character to debug info
      debugInfo.push({
        char: char,
        cp: cp,
        type: type,
        position: i,
        isBinary0: char === binary0,
        isBinary1: char === binary1
      });
      
      // Check for sneaky bits sequence
      if (detectSneakyBits && (char === binary0 || char === binary1)) {
        // We found a sneaky bit
        let binarySequence = '';
        let startIndex = i;
        let originalChars = [];
        let originalPositions = [];
        
        // Collect all consecutive binary characters
        while (i < message.length && 
               (message[i] === binary0 || message[i] === binary1)) {
          binarySequence += (message[i] === binary0) ? '0' : '1';
          originalChars.push(message[i]);
          originalPositions.push(i);
          i++;
        }
        
        // Count all binary characters individually
        stats.binaryBits += originalChars.length;
        
        // Make sure each binary character is in the debug info
        // We've already added the first one before this block
        for (let j = 1; j < originalPositions.length; j++) {
          let pos = originalPositions[j];
          let binChar = originalChars[j];
          let binCp = binChar.codePointAt(0);
          debugInfo.push({
            char: binChar,
            cp: binCp,
            type: 'binary',
            position: pos,
            isBinary0: binChar === binary0,
            isBinary1: binChar === binary1
          });
        }
        
        // Adjust i since the for loop will increment it again
        i--;
        
        // Mark as detected
        detected = true;
        sneakyBitsDetected = true;
        
        // Try to decode the binary sequence if it's a complete byte sequence
        let decodedText = '';
        let decodingSuccessful = false;
        
        if (binarySequence.length % 8 === 0) {
          try {
            let byteArray = [];
            for (let j = 0; j < binarySequence.length; j += 8) {
              let chunk = binarySequence.substr(j, 8);
              byteArray.push(parseInt(chunk, 2));
            }
            
            let decoder = new TextDecoder("utf-8");
            decodedText = decoder.decode(new Uint8Array(byteArray));
            
            if (decodedText && decodedText.length > 0) {
              decodingSuccessful = true;
            }
          } catch (e) {
            decodingSuccessful = false;
            console.error("Error decoding binary sequence:", e);
          }
        }
        
        // Display either the decoded text or the original binary characters
        if (decodingSuccessful) {
          // Display the decoded text with highlighting
          for (let j = 0; j < decodedText.length; j++) {
            const span = document.createElement('span');
            span.classList.add('binary');
            span.textContent = decodedText[j];
            span.title = "Decoded from Sneaky Bits";
            outputMessageElement.appendChild(span);
          }
        } else {
          // Display the original binary characters with highlighting
          for (let j = 0; j < originalChars.length; j++) {
            if (useHighlightMode) {
              const span = document.createElement('span');
              span.classList.add('binary');
              span.textContent = originalChars[j];
              span.title = "Binary " + (originalChars[j] === binary0 ? "0" : "1");
              outputMessageElement.appendChild(span);
            } else {
              // Even in non-highlight mode, we need to make these visible
              const span = document.createElement('span');
              span.classList.add('binary');
              span.textContent = originalChars[j] === binary0 ? "0" : "1";
              span.title = "Binary " + (originalChars[j] === binary0 ? "0" : "1");
              outputMessageElement.appendChild(span);
            }
          }
        }
      }
      // Handle Unicode Tags
      else if (detectUnicodeTags && cp >= 0xE0000 && cp <= 0xE007F) {
        detected = true;
        stats.unicodeTagCount++;
        
        if (useHighlightMode) {
          const span = document.createElement('span');
          span.classList.add('highlight');
          span.textContent = String.fromCharCode(cp - 0xE0000);
          span.title = "Unicode Tag: " + String.fromCharCode(cp - 0xE0000);
          outputMessageElement.appendChild(span);
        } else {
          outputMessageElement.textContent += String.fromCharCode(cp - 0xE0000);
        }
      }
      // Variant Selectors (first range)
      else if (detectVariantSelectors && cp >= 0xFE00 && cp <= 0xFE0F) {
        detected = true;
        stats.variantCount++;
        
        if (useHighlightMode) {
          const span = document.createElement('span');
          span.classList.add('variant');
          span.textContent = String.fromCharCode(cp - 0xFE00);
          span.title = "Variant Selector: " + String.fromCharCode(cp - 0xFE00);
          outputMessageElement.appendChild(span);
        } else {
          outputMessageElement.textContent += String.fromCharCode(cp - 0xFE00);
        }
      }
      // Variant Selectors (second range)
      else if (detectVariantSelectors && cp >= 0xE0100 + (16 - vs2Offset) && cp <= 0xE0100 + (255 - vs2Offset)) {
        detected = true;
        stats.variantCount++;
        
        if (useHighlightMode) {
          const span = document.createElement('span');
          span.classList.add('variant');
          span.textContent = String.fromCharCode((cp - 0xE0100) + vs2Offset);
          span.title = "Variant Selector: " + String.fromCharCode((cp - 0xE0100) + vs2Offset);
          outputMessageElement.appendChild(span);
        } else {
          outputMessageElement.textContent += String.fromCharCode((cp - 0xE0100) + vs2Offset);
        }
      }
      // Other Invisible Characters
      else if (detectOtherInvisible && invisibleMapping[cp]) {
        detected = true;
        stats.otherInvisibleCount++;
        
        if (useHighlightMode) {
          const span = document.createElement('span');
          span.classList.add('invisible');
          span.textContent = "U+" + cp.toString(16).toUpperCase();
          span.title = invisibleMapping[cp];
          outputMessageElement.appendChild(span);
        } else {
          outputMessageElement.textContent += String.fromCodePoint(cp);
        }
      }
      // Regular characters
      else {
        // Check if this is a binary character even if detection is off
        const isBinaryChar = char === binary0 || char === binary1;
        
        if (isBinaryChar) {
          // Always show binary characters, even if detection is off
          if (useHighlightMode) {
            const span = document.createElement('span');
            span.classList.add('binary');
            span.textContent = char === binary0 ? "0" : "1";
            span.title = "Binary " + (char === binary0 ? "0" : "1");
            outputMessageElement.appendChild(span);
          } else {
            // Even in non-highlight mode, we need to make these visible
            const span = document.createElement('span');
            span.classList.add('binary');
            span.textContent = char === binary0 ? "0" : "1";
            span.title = "Binary " + (char === binary0 ? "0" : "1");
            outputMessageElement.appendChild(span);
          }
        } else {
          if (useHighlightMode) {
            const span = document.createElement('span');
            span.textContent = char;
            outputMessageElement.appendChild(span);
          } else {
            outputMessageElement.textContent += char;
          }
        }
      }
      
      // Skip the second code unit for surrogate pairs
      if (inc === 2 && type === 'regular') {
        i++;
      }
    }
    
    // Update debug output
    updateDebugOutput(debugInfo);
    
    // Update status with statistics
    if (detected) {
      outputMessageElement.style.border = '2px solid red';
      
      // Calculate total hidden characters
      // This includes all Unicode tags, variant selectors, other invisible characters, and sneaky bits
      const totalHidden = stats.unicodeTagCount + stats.variantCount + stats.otherInvisibleCount + stats.binaryBits;
      
      // Update stats display
      document.getElementById('totalChars').textContent = stats.totalChars;
      document.getElementById('totalHiddenChars').textContent = totalHidden;
      document.getElementById('unicodeTagCount').textContent = stats.unicodeTagCount;
      document.getElementById('variantCount').textContent = stats.variantCount;
      document.getElementById('invisibleCount').textContent = stats.otherInvisibleCount;
      document.getElementById('binaryBits').textContent = stats.binaryBits;
      document.getElementById('binaryBytes').textContent = Math.floor(stats.binaryBits / 8);
      
      // Update status message
      let statusMsg = 'Hidden Unicode characters discovered';
      if (sneakyBitsDetected) {
        statusMsg += '. Sneaky Bits detected: ' + stats.binaryBits + ' binary characters';
      }
      updateStatus(statusMsg);
    } else {
      outputMessageElement.style.border = '1px solid #ccc';
      
      // Reset stats display
      document.getElementById('totalChars').textContent = stats.totalChars;
      document.getElementById('totalHiddenChars').textContent = '0';
      document.getElementById('unicodeTagCount').textContent = '0';
      document.getElementById('variantCount').textContent = '0';
      document.getElementById('invisibleCount').textContent = '0';
      document.getElementById('binaryBits').textContent = '0';
      document.getElementById('binaryBytes').textContent = '0';
      
      // Update status message
      updateStatus('No hidden text detected');
    }
  }

  function detectDecodingOptions(message) {
    let hasVariant = false;
    let hasBinary = false;
    const vs2Offset = parseInt(document.getElementById('vs2Offset').value, 10) || 16;
    let binaryRun = 0;
    for (let i = 0; i < message.length; i++) {
      let cp = message.codePointAt(i);
      if ((cp >= 0xFE00 && cp <= 0xFE00 + 15) ||
          (cp >= 0xE0100 + (16 - vs2Offset) && cp <= 0xE0100 + (255 - vs2Offset))) {
        hasVariant = true;
      }
      if (message[i] === binary0 || message[i] === binary1) {
        binaryRun++;
        if (binaryRun >= 8) {
          hasBinary = true;
        }
      } else {
        binaryRun = 0;
      }
    }
    return { hasVariant, hasBinary };
  }

  function updateStatus(message, isHighlighted = false) {
    const statusMessage = document.getElementById('statusMessage');
    statusMessage.textContent = message;
    statusMessage.style.fontSize = isHighlighted ? '16px' : '';
  }

  function resetStatus() {
    updateStatus('');
    document.getElementById('outputMessage').style.border = '1px solid #ccc';
  }

  function clearFields() {
    document.getElementById('inputMessage').value = '';
    document.getElementById('outputMessage').textContent = '';
    document.getElementById('debugOutput').innerHTML = '';
    resetStatus();
    
    // Reset stats display
    document.getElementById('totalChars').textContent = '0';
    document.getElementById('totalHiddenChars').textContent = '0';
    document.getElementById('unicodeTagCount').textContent = '0';
    document.getElementById('variantCount').textContent = '0';
    document.getElementById('invisibleCount').textContent = '0';
    document.getElementById('binaryBits').textContent = '0';
    document.getElementById('binaryBytes').textContent = '0';
  }

  function copyToClipboard() {
    navigator.clipboard.writeText(clipboardData).then(() => {
      updateStatus('Text copied to clipboard!', true);
    }).catch(err => {
      updateStatus('Failed to copy text: ' + err);
    });
  }

  function loadOptions() {
    const opts = JSON.parse(localStorage.getItem('asciiSmugglerOptions'));
    if (opts) {
      document.querySelector('input[name="encodingStrategy"][value="' + opts.encodingStrategy + '"]').checked = true;
      if (opts.encodingStrategy === 'variant') {
        document.getElementById('variantOptions').style.display = 'block';
      } else if (opts.encodingStrategy === 'binary') {
        document.getElementById('binaryOptions').style.display = 'block';
      } else if (opts.encodingStrategy === 'unicode') {
        document.getElementById('unicodeTagOptions').style.display = 'block';
      }
      document.getElementById('vs2Offset').value = opts.vs2Offset || 16;
      document.getElementById('binary0').value = opts.binary0 || "&#x2062;";
      document.getElementById('binary1').value = opts.binary1 || "&#x2064;";
      document.getElementById('decodeUriComponent').checked = opts.decodeUri || false;
      document.getElementById('highlightMode').checked = opts.highlightMode;
      document.getElementById('detectUnicodeTags').checked = opts.detectUnicodeTags;
      document.getElementById('detectVariantSelectors').checked = opts.detectVariantSelectors;
      document.getElementById('detectOtherInvisible').checked = opts.detectOtherInvisible;
      document.getElementById('detectSneakyBits').checked = opts.detectSneakyBits !== undefined ? opts.detectSneakyBits : true;
      document.getElementById('autoDecodeInput').checked = opts.autoDecodeInput || false;
      document.getElementById('showVerboseInfo').checked = opts.showVerboseInfo || false;
      if (opts.showVerboseInfo) {
        document.getElementById('verboseInfoSection').classList.add('visible');
      }
      if (opts.addExplicitTags !== undefined) {
        document.getElementById('addExplicitTags').checked = opts.addExplicitTags;
      }
      if (opts.debugFormat) {
        document.querySelector('input[name="debugFormat"][value="' + opts.debugFormat + '"]').checked = true;
      }
      if (opts.advancedOptionsVisible) {
        document.getElementById('advancedOptions').classList.add('visible');
      }
    } else {
      document.getElementById('highlightMode').checked = true;
      document.getElementById('detectSneakyBits').checked = true;
    }
  }
  document.addEventListener('DOMContentLoaded', loadOptions);

  function saveOptions() {
    const opts = {
      encodingStrategy: document.querySelector('input[name="encodingStrategy"]:checked').value,
      vs2Offset: document.getElementById('vs2Offset').value,
      binary0: document.getElementById('binary0').value,
      binary1: document.getElementById('binary1').value,
      decodeUri: document.getElementById('decodeUriComponent').checked,
      highlightMode: document.getElementById('highlightMode').checked,
      detectUnicodeTags: document.getElementById('detectUnicodeTags').checked,
      detectVariantSelectors: document.getElementById('detectVariantSelectors').checked,
      detectOtherInvisible: document.getElementById('detectOtherInvisible').checked,
      detectSneakyBits: document.getElementById('detectSneakyBits').checked,
      autoDecodeInput: document.getElementById('autoDecodeInput').checked,
      showVerboseInfo: document.getElementById('showVerboseInfo').checked,
      addExplicitTags: document.getElementById('addExplicitTags').checked,
      debugFormat: document.querySelector('input[name="debugFormat"]:checked').value,
      advancedOptionsVisible: document.getElementById('advancedOptions').classList.contains('visible')
    };
    localStorage.setItem('asciiSmugglerOptions', JSON.stringify(opts));
  }
  document.getElementById('decodeUriComponent').addEventListener('change', saveOptions);
  document.getElementById('highlightMode').addEventListener('change', function() {
    saveOptions();
    processMessage("decode");
  });
  document.getElementById('detectUnicodeTags').addEventListener('change', saveOptions);
  document.getElementById('detectVariantSelectors').addEventListener('change', saveOptions);
  document.getElementById('detectOtherInvisible').addEventListener('change', saveOptions);
  document.getElementById('detectSneakyBits').addEventListener('change', saveOptions);
  document.getElementById('autoDecodeInput').addEventListener('change', saveOptions);
  document.getElementById('showVerboseInfo').addEventListener('change', function() {
    document.getElementById('verboseInfoSection').classList.toggle('visible');
    saveOptions();
    processMessage('decode');
  });

  // Add event listeners to all option checkboxes to trigger auto-decode
  document.querySelectorAll('input[type="checkbox"], input[type="radio"]').forEach(input => {
    input.addEventListener('change', function() {
      // Don't auto-decode for the auto-decode option itself or the show verbose info option
      if (this.id !== 'autoDecodeInput' && this.id !== 'showVerboseInfo') {
        processMessage('decode');
      }
    });
  });

  // Add event listeners for character and emoji buttons
  document.querySelectorAll('.char-button, .emoji-button').forEach(button => {
    button.addEventListener('click', function() {
      const inputElement = document.getElementById('inputMessage');
      const char = this.getAttribute('data-char');
      const startPos = inputElement.selectionStart;
      const endPos = inputElement.selectionEnd;
      
      // Insert the character at cursor position
      inputElement.value = inputElement.value.substring(0, startPos) + char + inputElement.value.substring(endPos);
      
      // Move cursor position after the inserted character
      inputElement.selectionStart = inputElement.selectionEnd = startPos + char.length;
      
      // Focus back on the input
      inputElement.focus();
    });
  });

  // Debug format radio buttons
  document.querySelectorAll('input[name="debugFormat"]').forEach(radio => {
    radio.addEventListener('change', function() {
      const message = document.getElementById('inputMessage').value;
      if (message) {
        processMessage('decode');
      }
      saveOptions();
    });
  });

  function updateDebugOutput(debugInfo) {
    const debugOutputElement = document.getElementById('debugOutput');
    const debugFormat = document.querySelector('input[name="debugFormat"]:checked').value;
    
    let output = '';
    for (let entry of debugInfo) {
      let formattedValue = '';
      
      if (debugFormat === 'binary') {
        // Ensure proper padding for binary representation
        // Unicode code points can be up to 21 bits, so we'll use a minimum of 21 bits
        // For ASCII (0-127), we'll use 8 bits
        // For other Unicode points, we'll use 16 or 21 bits as needed
        if (entry.cp <= 127) {
          formattedValue = entry.cp.toString(2).padStart(8, '0'); // ASCII: 8 bits
        } else if (entry.cp <= 65535) {
          formattedValue = entry.cp.toString(2).padStart(16, '0'); // BMP: 16 bits
        } else {
          formattedValue = entry.cp.toString(2).padStart(21, '0'); // Supplementary planes: 21 bits
        }
      } else if (debugFormat === 'hex') {
        formattedValue = entry.cp.toString(16).toUpperCase().padStart(4, '0');
      } else if (debugFormat === 'unicode') {
        formattedValue = 'U+' + entry.cp.toString(16).toUpperCase().padStart(4, '0');
      }
      
      let className = '';
      let title = '';
      
      // Check if this is a binary character (either by type or by direct comparison)
      const isBinary = entry.type === 'binary' || 
                       entry.isBinary0 === true || 
                       entry.isBinary1 === true;
      
      if (entry.type === 'tag') {
        className = 'highlight';
        title = `Unicode Tag: ${entry.char}`;
      } else if (entry.type === 'variant') {
        className = 'variant';
        title = `Variant Selector: ${entry.char}`;
      } else if (entry.type === 'invisible') {
        className = 'invisible';
        title = invisibleMapping[entry.cp] || 'Invisible Character';
      } else if (isBinary) {
        className = 'binary';
        // Determine if it's a 0 or 1 binary character
        const isBinary0Value = entry.isBinary0 === true;
        title = `Binary ${isBinary0Value ? '0' : '1'}`;
      } else {
        title = `Character: ${entry.char}`;
      }
      
      if (className) {
        output += `<span class="${className}" title="${title}">${formattedValue}</span> `;
      } else {
        output += `<span title="${title}">${formattedValue}</span> `;
      }
    }
    
    debugOutputElement.innerHTML = output;
  }
</script>
</body>
</html>
